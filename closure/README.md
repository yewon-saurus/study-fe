# closure

## 01.js

- outerFunc 내에서 내부함수 innerFunc가 선언되고 호출되고 있습니다.
- innerFunc는 자신을 포함하고 있는 outerFunc의 변수 x에 접근할 수 있습니다.
- 이건 뭐죠?
    - innerFunc가 함수 outerFunc의 내부에 선언되었기 때문에 가능한 것입니다.
- innerFunc는 자신이 속한 Lexical Scope(전역, outerFunc, 자신의 스코프)를 참조할 수 있다.

## 02.js

- 01.js와 거의 같으나, 이번에는 outerFunc에서 innerFunc을 return하는 형태입니다.
- 함수 outerFunc를 호출하면, 내부 함수 innerFunc가 반환됩니다. 직후, **함수 outerFunc의 실행 컨텍스트는 소멸**합니다.
- 이미 life-cycle이 종료되어 실행 컨텍스트 스택에서 제거된 함수 outerFunc의 지역변수 x가 여전히 동작하고 있습니다!!
- (얄코님의 Hector, Coco 예시를 떠올리기)
- 이처럼, outerFunc 바깥에서 innerFunc가 호출되는 경우, outerFunc의 지역 변수에 접근할 수 있는데, 이러한 함수를 closure라고 합니다.
- 다시 말해, **반환된 내부함수가 자신이 선언되었을 때의 렉시컬 스코프를 기억하여, 자신이 선언되었을 때의 스코프 밖에서 호출되더라도 그 스코프에 접근할 수 있는 함수**라고 말할 수 있습니다.
- 클로저에 의해 참조되는 변수(여기서는, outerFunc의 `x`)를 **자유 변수**라고 합니다.
- 클로저라는 이름은 '자유변수에 의해 함수가 닫혀있다'라는 의미로 의역할 수 있습니다.


## 03.html - button toggle
[클로저의 활용 (1) - 상태 유지]

- **즉시 실행 함수**는 함수를 반환하고 즉시 소멸합니다. 여기서, 즉시 실행 함수가 반환한 함수는 **자신이 생성됐을 때의 렉시컬 스코프에 속한 `isShow`를 기억하는 클로저입니다.
- (getElementsByClassName이 아니라 querySelector를 썼구나)
- 클로저를 이벤트 핸들러로서 이벤트 프로퍼티에 할당했습니다. (`button.onclick = toggle;`)
    - 이벤트 핸들러로 할당된 클로저를 제거하지 않는 한, 클로저가 기억하는 렉시컬 스코프의 변수 `isShow`는 소멸하지 않습니다.
    - `isShow`는 클로저에 의해 참조되고 있기 때문에 유효하며, 자신의 변경된 최신 상태를 계속해서 유지합니다.
- 이처럼 클로저는 **현재 상태를 기억하고 ~ 이 상태가 변경되더라도 최신 상태를 유지해야 하는 상황**에 유옹합니다.
    - 만약 클로저라는 기능이 없다면, 상태를 유지하기 위해 전역 변수를 사용할 수밖에 없었을 터 입니다만..
    - 전역 변수는 언제든지 누구나 접근할 수 있기 때문에 -> 부작용을 유발해 오류의 원인이 되므로 -> 사용을 억제해야 합니다.

## 04.html - counter
[클로저의 활용 (2) - 전역 변수의 사용 억제]

- 즉시실행함수가 호출되고, 변수 `increase`에 `function () { return ++counter; }`가 할당됩니다. 이 함수 또한 클로저 입니다.
- 이처럼, 클로저는 **불변성(Immutability)을 지향**하는 함수형 프로그래밍에서 **부수 효과(Side Effect)를 최대한 억제**하여 오류를 피하기 위해 적극적으로 사용됩니다.

## 05.js - 생성자 함수 Counter
[클로저의 활용 (3) - 정보 은닉]

- 생성자 함수 `Counter()`가 메서드 `increase`와 `decrease`를 갖는 인스턴스를 생성합니다.
- 이 메서드들은 각각 자신이 생성됐을 때의 렉시컬 환경인 `Counter()`의 스코프에 속한 변수 `counter`를 기억하는 클로저입니다.
- 이 메서드들은 같은 렉시컬 환경을 공유하고 있습니다.
- (주의!) `counter`는 this에 바인딩 된 프로퍼티가 아니라, 변수입니다.
    - this에 바인딩된 프로퍼티였다면, 생성자 함수 Counter가 생성한 인스턴스를 통해 public 프로퍼티가 되었을 것입니다.
    - increase, decrease는 클로저이기 때문에, counter에 접근할 수 있습니다.
    - 즉, 클로저의 특징을 사용해 마치 클래스 기반 언어인 것처럼, private 흉내를 낼 수 있는 것입니다.
    - (최신 JS에는 private 프로퍼티 문법이 추가돼 있습니다.) (ES2019에 추가됐다고 합니다.)
